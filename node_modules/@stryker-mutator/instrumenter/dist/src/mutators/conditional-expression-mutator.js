"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.conditionalExpressionMutator = void 0;
const core_1 = require("@babel/core");
const booleanOperators = Object.freeze(['!=', '!==', '&&', '<', '<=', '==', '===', '>', '>=', '||']);
exports.conditionalExpressionMutator = {
    name: 'ConditionalExpression',
    *mutate(path) {
        if (isTestOfLoop(path)) {
            yield core_1.types.booleanLiteral(false);
        }
        else if (isTestOfCondition(path)) {
            yield core_1.types.booleanLiteral(true);
            yield core_1.types.booleanLiteral(false);
        }
        else if (isBooleanExpression(path)) {
            yield core_1.types.booleanLiteral(true);
            yield core_1.types.booleanLiteral(false);
        }
        else if (path.isForStatement() && !path.node.test) {
            const replacement = core_1.types.cloneNode(path.node, /* deep */ true);
            replacement.test = core_1.types.booleanLiteral(false);
            yield replacement;
        }
        else if (path.isSwitchCase() && path.node.consequent.length > 0) {
            // if not a fallthrough case
            const replacement = core_1.types.cloneNode(path.node);
            replacement.consequent = [];
            yield replacement;
        }
    },
};
function isTestOfLoop(path) {
    const { parentPath } = path;
    if (!parentPath) {
        return false;
    }
    return (parentPath.isForStatement() || parentPath.isWhileStatement() || parentPath.isDoWhileStatement()) && parentPath.node.test === path.node;
}
function isTestOfCondition(path) {
    const { parentPath } = path;
    if (!parentPath) {
        return false;
    }
    return parentPath.isIfStatement() /*|| parentPath.isConditionalExpression()*/ && parentPath.node.test === path.node;
}
function isBooleanExpression(path) {
    return (path.isBinaryExpression() || path.isLogicalExpression()) && booleanOperators.includes(path.node.operator);
}
//# sourceMappingURL=conditional-expression-mutator.js.map